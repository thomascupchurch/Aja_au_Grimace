<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Project Gantt (Read-only)</title>
  <link rel="icon" href="/favicon.ico">
  <!-- Fallback minimal CSS -->
  <link rel="stylesheet" href="/static/frappe-gantt.css">
  <!-- Optional vendored full CSS (overrides) -->
  <link rel="stylesheet" href="/static/vendor/frappe-gantt.css" onerror="this.remove()">
  <!-- Dark theme overrides to match desktop app (#4B4B4B) -->
  <style>
    :root {
      /* Gantt CSS variable overrides for dark background */
      --g-header-background: #4B4B4B;
      --g-row-color: #585858;
      --g-row-border-color: #6a6a6a;
      --g-text-dark: #f3f4f6;           /* near-white for labels */
      --g-text-muted: #d1d5db;          /* light gray */
      --g-tick-color: #6b7280;          /* slate-ish */
      --g-tick-color-thick: #81858f;
      --g-arrow-color: #d1d5db;
      --g-progress-color: #9ca3af;      /* progress fill on dark */
      --g-expected-progress: #a7a7d6;
      --g-today-highlight: #ffffff66;   /* subtle, semi-transparent */
      --g-actions-background: #4B4B4B;
      --g-popup-actions: #5b5b5b;
      --g-weekend-highlight-color: #4B4B4B; /* blend with background to reduce noise */
      --g-bar-border: transparent;
    }
  </style>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; background:#4B4B4B; color:#f5f5f5; }
    header { padding: 12px 16px; background: #4B4B4B; color: #fff; display:flex; align-items:center; gap:12px; border-bottom:1px solid #6a6a6a; }
    header img { height: 28px; }
    main { padding: 12px; background:#4B4B4B; }
    #gantt { overflow-x: auto; border-top: 1px solid #6a6a6a; }
    .toolbar { display:flex; gap:8px; align-items:center; padding:8px 0; }
    .toolbar select, .toolbar button { padding:6px 10px; background:#fff; color:#222; border:1px solid #cfcfcf; border-radius:6px; }
    .toolbar label { color:#e5e7eb; }
    .info { margin: 8px 0; color:#e5e7eb; font-size: 12px; }
    .empty { padding: 24px; color:#e5e7eb; text-align:center; }
    .error { padding: 12px; color: #fee; background:#7f1d1d; border:1px solid #fca5a5; margin:8px 0; border-radius:6px; }
    #gantt > div { min-height: 320px; }
    /* Reduce busyness: hide diagonal hatch for ignored dates */
    .gantt .ignored-bar { display: none; }
  </style>
</head>
<body>
  <header>
    <img src="/static/header.png" alt="Header" onerror="this.style.display='none'"/>
    <div>Project Gantt (Read-only)</div>
  </header>
  <main>
    <div class="toolbar">
      <label>Display:</label>
      <select id="display-mode">
        <option value="gantt">Gantt</option>
        <option value="calendar">Calendar</option>
        <option value="timeline">Timeline</option>
        <option value="tree">Tree</option>
      </select>
      
      <label>View:</label>
      <select id="view-mode">
        <option value="Day">Day</option>
        <option value="Week">Week</option>
        <option value="Month">Month</option>
        <option value="Year">Year</option>
      </select>
      <button id="refresh">Refresh</button>
    </div>
    <div class="info" id="db-info"></div>
    <div class="info" id="status"></div>
    <div id="gantt-view" class="view">
      <div id="gantt"></div>
    </div>
    <div id="calendar-view" class="view" hidden>
      <div class="cal-toolbar">
        <button id="cal-prev" title="Previous Month">◀</button>
        <div id="cal-title" class="cal-title"></div>
        <button id="cal-next" title="Next Month">▶</button>
      </div>
      <div id="calendar" class="calendar"></div>
      <div id="calendar-details" class="calendar-details"></div>
    </div>
    <div id="timeline-view" class="view" hidden>
      <div id="timeline" class="timeline"></div>
    </div>
    <div id="tree-view" class="view" hidden>
      <div id="tree" class="tree"></div>
    </div>
  </main>

  <!-- Prefer local vendored asset (.min.js or .umd.js); fall back to CDN; then to tiny local stub route -->
  <script>
    (function(){
      function inject(src, next){
        var s=document.createElement('script');
        s.src=src;
        s.onload=function(){
          // If script loaded but didn't define Gantt, continue chain
          if(typeof window.Gantt !== 'function') {
            if(next) next();
          }
        };
        s.onerror=function(){ if(next) next(); };
        document.body.appendChild(s);
      }
      // try local vendor (serves .umd.js or .min.js if present & valid)
      inject('/static/vendor/frappe-gantt.umd.js', function(){
        // try CDN UMD
        inject('https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.umd.js', function(){
          // final local stub
          inject('/static/frappe-gantt.umd.js');
        });
      });
    })();
  </script>
  <script>
    let gantt;
    let cachedTasks = null; // cache parsed Date objects for re-render without refetching
  let currentMode = 'gantt';
    let calMonth = null; // Date at first of month for calendar
    const body = document.body;
    
    // Wait for frappe-gantt to be loaded (window.Gantt defined)
    async function waitForGantt(timeoutMs = 8000) {
      const start = Date.now();
      while (typeof window.Gantt !== 'function') {
        if (Date.now() - start > timeoutMs) return false;
        await new Promise(r => setTimeout(r, 50));
      }
      return true;
    }

    // Compute overall date range of tasks
    function computeRange(tasks) {
      let min = null, max = null;
      for (const t of tasks || []) {
        if (!(t.start instanceof Date) || !(t.end instanceof Date)) continue;
        if (!min || t.start < min) min = t.start;
        if (!max || t.end > max) max = t.end;
      }
      return { min, max };
    }

    // Count columns for a given view between [start, end] inclusive
    function countColumns(view, start, end) {
      if (!start || !end) return 1;
      const msPerDay = 24*60*60*1000;
      const days = Math.max(1, Math.ceil((end - start) / msPerDay) + 1);
      switch(view) {
        case 'Day':
          return days + 2; // padding
        case 'Week':
          return Math.ceil(days / 7) + 1;
        case 'Month': {
          // Count month ticks inclusive
          let c = 1;
          let d = new Date(start.getFullYear(), start.getMonth()+1, 1);
          while (d <= end) { c++; d = new Date(d.getFullYear(), d.getMonth()+1, 1); }
          return c;
        }
        case 'Year':
          return end.getFullYear() - start.getFullYear() + 1;
        default:
          return days + 2;
      }
    }

    // Choose view mode and column_width that approximately fits container width
    function chooseFitSettings(containerWidth, tasks, preferredView) {
      const { min, max } = computeRange(tasks);
      const views = preferredView ? [preferredView] : ['Day','Week','Month','Year'];
      const bounds = { min: 12, max: 80 };
      for (const v of views) {
        const cols = Math.max(1, countColumns(v, min, max));
        const ideal = Math.floor(containerWidth / cols);
        if (ideal >= bounds.min && ideal <= bounds.max) {
          return { view: v, column_width: ideal };
        }
      }
      // Fallback: pick the last tried view and clamp
      const last = views[views.length - 1];
      const cols = Math.max(1, countColumns(last, min, max));
      return { view: last, column_width: Math.max(bounds.min, Math.min(bounds.max, Math.floor(containerWidth / cols))) };
    }

    function renderGantt(parsed, opts={}) {
      const el = document.querySelector('#gantt');
      el.innerHTML = '';
      const container = document.createElement('div');
      el.appendChild(container);

      const toolbarView = document.querySelector('#view-mode').value;
      const cw = chooseFitSettings(container.clientWidth || el.clientWidth || 1024, parsed, opts.view || toolbarView);
      // keep the select in sync with chosen view
      document.querySelector('#view-mode').value = cw.view;

      // Helper to (re)apply progress colors and add label backgrounds
      const enhanceBars = () => {
        if (!gantt) return;
        gantt.$svg.querySelectorAll('.bar-label-bg').forEach(n => n.remove());
        for (const t of parsed) {
          const group = gantt.$svg.querySelector(`.bar-wrapper[data-id="${t.id}"]`);
          if (!group) continue;
          const prog = group.querySelector('.bar-progress');
          if (prog && t.color_progress) {
            try { prog.style.fill = t.color_progress; } catch {}
          }
          const label = group.querySelector('.bar-label');
          if (label) {
            try {
              const bbox = label.getBBox();
              const padX = 6, padY = 3, rx = 4;
              const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
              rect.setAttribute('x', String(bbox.x - padX));
              rect.setAttribute('y', String(bbox.y - padY));
              rect.setAttribute('width', String(bbox.width + padX * 2));
              rect.setAttribute('height', String(bbox.height + padY * 2));
              rect.setAttribute('rx', String(rx));
              rect.setAttribute('ry', String(rx));
              rect.setAttribute('class', 'bar-label-bg');
              rect.setAttribute('fill', '#FF8200');
              rect.setAttribute('pointer-events', 'none');
              const ie = (t.internal_external || '').toLowerCase();
              const stroke = ie === 'internal' ? '#ffffff' : (ie === 'external' ? '#000000' : 'none');
              const strokeWidth = stroke === 'none' ? '0' : '2';
              rect.setAttribute('stroke', stroke);
              rect.setAttribute('stroke-width', strokeWidth);
              label.parentNode.insertBefore(rect, label);
              // Ensure label text is readable over orange background
              label.style.fill = '#111';
            } catch {}
          }
        }
      };

      gantt = new Gantt(container, parsed, {
        view_mode: cw.view,
        column_width: cw.column_width,
        date_format: 'YYYY-MM-DD',
        language: 'en',
        lines: 'vertical',
        today_button: true,
        ignore: 'weekend',
        holidays: { 'var(--g-weekend-highlight-color)': 'weekend' },
        view_mode_select: true,
        on_view_change: () => { requestAnimationFrame(enhanceBars); },
        custom_popup_html: task => {
          const fields = [
            ['Name', task.name],
            ['Start', t(task.start)],
            ['End', t(task.end)],
            ['Progress', `${task.progress}%`],
            ['Type', task.type],
            ['Dependencies', task.dependencies]
          ];
          function t(d) { try { return d?.toISOString?.().slice(0,10) || d; } catch { return d; } }
          return `<div class="details-container">${fields.map(([k,v]) => `<div><strong>${k}:</strong> ${v||''}</div>`).join('')}</div>`;
        }
      });
      requestAnimationFrame(enhanceBars);

      // Re-apply enhancements on scroll/pan and DOM churn
      const scrollBox = container.querySelector('.gantt-container') || el;
      let scrollDebounce;
      const triggerEnhance = () => {
        if (!gantt) return;
        requestAnimationFrame(enhanceBars);
        clearTimeout(scrollDebounce);
        scrollDebounce = setTimeout(() => requestAnimationFrame(enhanceBars), 60);
      };
      scrollBox.addEventListener('scroll', triggerEnhance, { passive: true });
      el.addEventListener('scroll', triggerEnhance, { passive: true });
      scrollBox.addEventListener('wheel', triggerEnhance, { passive: true });
      el.addEventListener('wheel', triggerEnhance, { passive: true });
      const mo = new MutationObserver(() => {
        if (!gantt) return;
        // Debounce to avoid loops
        clearTimeout(scrollDebounce);
        scrollDebounce = setTimeout(() => requestAnimationFrame(enhanceBars), 20);
      });
      try { mo.observe(gantt.$svg, { childList: true, subtree: true }); } catch {}
    }

    async function loadTasks() {
      // Show DB path and row count to help diagnose empty data
      try {
        const dbg = await fetch('/api/debug').then(r => r.json());
        const info = document.querySelector('#db-info');
        info.textContent = `DB: ${dbg.db_path || 'unknown'} | exists: ${dbg.db_exists} | project_parts rows: ${dbg.row_count}`;
      } catch (e) {
        console.warn('debug fetch failed', e);
      }

      const res = await fetch('/api/tasks');
      const tasks = await res.json();
      document.querySelector('#status').textContent = `Tasks fetched: ${tasks?.length ?? 0}`;
      const target = currentMode === 'calendar' ? document.getElementById('calendar') : (currentMode === 'timeline' ? document.getElementById('timeline') : document.getElementById('gantt'));
      if (target) target.innerHTML = '';
      if (!tasks || tasks.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty';
        empty.textContent = 'No tasks to show. Verify your database path (PROJECT_DB_PATH or db_path.txt) and that project_parts has data.';
        (target || document.body).appendChild(empty);
        return;
      }
      // Convert to Date objects to avoid client-side parsing quirks
      const parsed = tasks.map(t => ({
        ...t,
        start: new Date(t.start),
        end: new Date(t.end)
      }));
      cachedTasks = parsed;
      try {
        // Render according to current mode
        if (currentMode === 'gantt') {
          const ok = await waitForGantt(8000);
          if (!ok) throw new Error('Gantt library not loaded');
          renderGantt(parsed);
        } else if (currentMode === 'calendar') {
          ensureCalMonth(parsed);
          renderCalendar(parsed, calMonth);
        } else if (currentMode === 'timeline') {
          renderTimeline(parsed);
        } else if (currentMode === 'tree') {
          renderTree(parsed);
        }
      } catch (e) {
        console.error('Render error', e);
        const err = document.createElement('div');
        err.className = 'error';
        err.textContent = `Error rendering: ${e?.message || e}`;
        (target || document.body).appendChild(err);
        // As a fallback, list first few tasks
        const pre = document.createElement('pre');
        pre.textContent = JSON.stringify(parsed.slice(0,5), null, 2);
        (target || document.body).appendChild(pre);
      }
    }

    document.querySelector('#view-mode').addEventListener('change', () => {
      // Re-render with the chosen view, still fitting the width
      if (cachedTasks) renderGantt(cachedTasks, { view: document.querySelector('#view-mode').value });
    });
    document.querySelector('#refresh').addEventListener('click', loadTasks);

    // Display mode switching
    function setMode(mode) {
      currentMode = mode;
      body.classList.remove('mode-gantt','mode-calendar','mode-timeline');
      body.classList.add(`mode-${mode}`);
      // Toggle view containers
      document.getElementById('gantt-view').hidden = mode !== 'gantt';
      document.getElementById('calendar-view').hidden = mode !== 'calendar';
  document.getElementById('timeline-view').hidden = mode !== 'timeline';
  document.getElementById('tree-view').hidden = mode !== 'tree';
      // Render immediately if we already have data
      if (!cachedTasks) return;
      if (mode === 'gantt') {
        waitForGantt(8000).then(ok => { if (ok) renderGantt(cachedTasks); });
      } else if (mode === 'calendar') {
        ensureCalMonth(cachedTasks);
        renderCalendar(cachedTasks, calMonth);
      } else if (mode === 'timeline') {
        renderTimeline(cachedTasks);
      } else if (mode === 'tree') {
        renderTree(cachedTasks);
      }
    }
    document.getElementById('display-mode').addEventListener('change', (e) => setMode(e.target.value));

    loadTasks();

    // Fit on resize
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      if (!cachedTasks) return;
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        if (currentMode === 'gantt') renderGantt(cachedTasks);
        else if (currentMode === 'calendar') renderCalendar(cachedTasks, calMonth);
        else if (currentMode === 'timeline') renderTimeline(cachedTasks);
        else if (currentMode === 'tree') renderTree(cachedTasks);
      }, 120);
    });

    // ---- Calendar view implementation ----
    function ensureCalMonth(tasks) {
      if (calMonth) return;
      const { min, max } = computeRange(tasks);
      const today = new Date();
      let base = today;
      if (min && max) {
        const mid = new Date((min.getTime() + max.getTime())/2);
        base = mid;
      }
      calMonth = new Date(base.getFullYear(), base.getMonth(), 1);
    }

    function monthName(d) {
      return d.toLocaleString(undefined, { month: 'long', year: 'numeric' });
    }

    function dayKey(d) { return d.toISOString().slice(0,10); }

    function overlapsDay(t, day) {
      const start = new Date(day.getFullYear(), day.getMonth(), day.getDate(), 0,0,0,0);
      const end = new Date(day.getFullYear(), day.getMonth(), day.getDate(), 23,59,59,999);
      return t.start <= end && t.end >= start;
    }

    function buildCalendarGrid(monthDate) {
      const first = new Date(monthDate.getFullYear(), monthDate.getMonth(), 1);
      const start = new Date(first);
      start.setDate(start.getDate() - start.getDay()); // back to Sunday
      const cells = [];
      for (let i=0; i<42; i++) {
        const d = new Date(start);
        d.setDate(start.getDate() + i);
        cells.push(d);
      }
      return cells;
    }

    function renderCalendar(tasks, monthDate) {
      const grid = document.getElementById('calendar');
      grid.innerHTML = '';
      const details = document.getElementById('calendar-details');
      const title = document.getElementById('cal-title');
      title.textContent = monthName(monthDate);

      // header row for weekdays
      const weekdays = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
      const head = document.createElement('div');
      head.className = 'cal-head';
      for (const w of weekdays) {
        const c = document.createElement('div');
        c.className = 'cal-head-cell';
        c.textContent = w;
        head.appendChild(c);
      }
      grid.appendChild(head);

      const cells = buildCalendarGrid(monthDate);
      const todayKey = dayKey(new Date());
      const monthIdx = monthDate.getMonth();
      const frag = document.createDocumentFragment();
      for (const d of cells) {
        const cell = document.createElement('div');
        cell.className = 'cal-cell';
        if (d.getMonth() !== monthIdx) cell.classList.add('dim');
        const dk = dayKey(d);
        if (dk === todayKey) cell.classList.add('today');
        const dayNum = document.createElement('div');
        dayNum.className = 'cal-daynum';
        dayNum.textContent = String(d.getDate());
        cell.appendChild(dayNum);

        // count tasks overlapping the day
        let count = 0;
        const items = [];
        for (const t of tasks) {
          if (overlapsDay(t, d)) { count++; items.push(t); }
        }
        if (count > 0) {
          const badge = document.createElement('div');
          badge.className = 'cal-badge';
          badge.textContent = String(count);
          cell.appendChild(badge);
        }
        cell.addEventListener('click', () => {
          renderCalDetails(d, items);
        });
        frag.appendChild(cell);
      }
      grid.appendChild(frag);

      // default details: today or first of month
      const base = (cells.find(d => dayKey(d) === todayKey) || new Date(monthDate));
      const baseItems = tasks.filter(t => overlapsDay(t, base));
      renderCalDetails(base, baseItems);
    }

    function renderCalDetails(day, items) {
      const details = document.getElementById('calendar-details');
      details.innerHTML = '';
      const h = document.createElement('div');
      h.className = 'cal-details-title';
      h.textContent = day.toLocaleDateString(undefined, { weekday:'long', month:'long', day:'numeric', year:'numeric' });
      details.appendChild(h);
      if (!items || items.length === 0) {
        const p = document.createElement('div');
        p.className = 'empty';
        p.textContent = 'No tasks on this day.';
        details.appendChild(p);
        return;
      }
      const list = document.createElement('ul');
      list.className = 'cal-list';
      for (const t of items) {
        const li = document.createElement('li');
        const dot = document.createElement('span');
        dot.className = 'cal-dot';
        dot.style.background = t.color_progress || '#FF8200';
        const name = document.createElement('span');
        name.className = 'cal-name';
        name.textContent = t.name;
        const when = document.createElement('span');
        when.className = 'cal-when';
        const s = t.start.toISOString().slice(0,10);
        const e = t.end.toISOString().slice(0,10);
        when.textContent = `${s} → ${e}`;
        li.appendChild(dot);
        li.appendChild(name);
        li.appendChild(when);
        list.appendChild(li);
      }
      details.appendChild(list);
    }

    document.getElementById('cal-prev').addEventListener('click', () => {
      if (!calMonth) return; calMonth = new Date(calMonth.getFullYear(), calMonth.getMonth()-1, 1);
      if (cachedTasks) renderCalendar(cachedTasks, calMonth);
    });
    document.getElementById('cal-next').addEventListener('click', () => {
      if (!calMonth) return; calMonth = new Date(calMonth.getFullYear(), calMonth.getMonth()+1, 1);
      if (cachedTasks) renderCalendar(cachedTasks, calMonth);
    });

    // ---- Timeline view implementation ----
    function renderTimeline(tasks) {
      const container = document.getElementById('timeline');
      container.innerHTML = '';
      const { min, max } = computeRange(tasks);
      if (!min || !max) return;
      const padDays = 1;
      const start = new Date(min.getFullYear(), min.getMonth(), min.getDate() - padDays);
      const end = new Date(max.getFullYear(), max.getMonth(), max.getDate() + padDays);
      const msPerDay = 24*60*60*1000;
      const totalDays = Math.max(1, Math.ceil((end - start) / msPerDay));
      const width = container.clientWidth || 1024;
      const rowH = 22; const padding = 48;
      const tasksSorted = tasks.slice().sort((a,b)=>a.start-b.start || a.end-b.end);
      const height = padding + tasksSorted.length * rowH + 30;

      function xFor(d) { return padding + ((d - start) / msPerDay) * (width - padding*2) / totalDays; }

      const svgNS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('width', String(width));
      svg.setAttribute('height', String(height));
      svg.classList.add('timeline-svg');

      // Month grid lines and labels
      let tick = new Date(start.getFullYear(), start.getMonth(), 1);
      while (tick <= end) {
        const x = xFor(tick);
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', String(x));
        line.setAttribute('y1', '0');
        line.setAttribute('x2', String(x));
        line.setAttribute('y2', String(height));
        line.setAttribute('stroke', '#6a6a6a');
        line.setAttribute('stroke-width', '1');
        svg.appendChild(line);
        const lbl = document.createElementNS(svgNS, 'text');
        lbl.setAttribute('x', String(x + 4));
        lbl.setAttribute('y', '14');
        lbl.setAttribute('fill', '#e5e7eb');
        lbl.setAttribute('font-size', '12');
        lbl.textContent = tick.toLocaleString(undefined, { month:'short', year:'numeric' });
        svg.appendChild(lbl);
        tick = new Date(tick.getFullYear(), tick.getMonth()+1, 1);
      }

      // Today marker
      const today = new Date();
      const tx = xFor(new Date(today.getFullYear(), today.getMonth(), today.getDate()));
      const tline = document.createElementNS(svgNS, 'line');
      tline.setAttribute('x1', String(tx));
      tline.setAttribute('y1', '0');
      tline.setAttribute('x2', String(tx));
      tline.setAttribute('y2', String(height));
      tline.setAttribute('stroke', '#ffffff66');
      tline.setAttribute('stroke-width', '2');
      svg.appendChild(tline);

      // Bars
      tasksSorted.forEach((t, i) => {
        const y = padding + i * rowH;
        const x1 = xFor(t.start);
        const x2 = xFor(t.end);
        const bw = Math.max(3, x2 - x1);
        const rect = document.createElementNS(svgNS, 'rect');
        rect.setAttribute('x', String(x1));
        rect.setAttribute('y', String(y));
        rect.setAttribute('width', String(bw));
        rect.setAttribute('height', '14');
        rect.setAttribute('rx', '3');
        rect.setAttribute('fill', t.color_progress || '#FF8200');
        svg.appendChild(rect);
        const label = document.createElementNS(svgNS, 'text');
        label.setAttribute('x', String(x1 + 4));
        label.setAttribute('y', String(y + 12));
        label.setAttribute('fill', '#111');
        label.setAttribute('font-size', '12');
        label.textContent = t.name;
        svg.appendChild(label);
      });

      container.appendChild(svg);
    }

    // ---- Tree view implementation ----
    function buildTree(tasks) {
      const byId = new Map();
      const roots = [];
      tasks.forEach(t => { byId.set(t.id, { ...t, children: [] }); });
      // Attach children to parents where possible; non-existent parents treated as roots
      byId.forEach(node => {
        const pid = node.parent_id;
        if (pid && byId.has(pid) && pid !== node.id) {
          byId.get(pid).children.push(node);
        } else {
          roots.push(node);
        }
      });
      return roots;
    }

    function renderTree(tasks) {
      const container = document.getElementById('tree');
      container.innerHTML = '';
      const roots = buildTree(tasks);
      // Simple list with indentation and expand/collapse
      const list = document.createElement('div');
      list.className = 'tree-list';
      container.appendChild(list);

      function row(node, depth=0) {
        const r = document.createElement('div');
        r.className = 'tree-row';
        r.style.paddingLeft = `${depth*16 + 8}px`;
        const toggle = document.createElement('button');
        toggle.className = 'tree-toggle';
        toggle.textContent = node.children && node.children.length ? '▾' : '•';
        toggle.disabled = !(node.children && node.children.length);
        const name = document.createElement('span');
        name.className = 'tree-name';
        name.textContent = node.name;
        const when = document.createElement('span');
        when.className = 'tree-when';
        const s = new Date(node.start).toISOString().slice(0,10);
        const e = new Date(node.end).toISOString().slice(0,10);
        when.textContent = `${s} → ${e}`;
        const prog = document.createElement('span');
        prog.className = 'tree-progress';
        prog.textContent = `${node.progress ?? 0}%`;
        prog.style.background = node.color_progress || '#FF8200';
        r.appendChild(toggle);
        r.appendChild(name);
        r.appendChild(when);
        r.appendChild(prog);

        let expanded = true;
        const childWrap = document.createElement('div');
        childWrap.className = 'tree-children';
        r.appendChild(childWrap);
        function rerenderChildren() {
          childWrap.innerHTML = '';
          if (!expanded) return;
          (node.children||[]).forEach(c => childWrap.appendChild(row(c, depth+1)));
        }
        toggle.addEventListener('click', () => {
          if (!node.children || !node.children.length) return;
          expanded = !expanded;
          toggle.textContent = expanded ? '▾' : '▸';
          rerenderChildren();
        });
        rerenderChildren();
        return r;
      }
      roots.forEach(n => list.appendChild(row(n, 0)));
    }
  </script>
  <style>
    /* Mode-specific control visibility */
    body.mode-gantt .toolbar #view-mode, body.mode-gantt .toolbar label:nth-of-type(2) { display: inline-block; }
    body.mode-calendar .toolbar #view-mode, body.mode-calendar .toolbar label:nth-of-type(2),
    body.mode-timeline .toolbar #view-mode, body.mode-timeline .toolbar label:nth-of-type(2) { display: none; }

    /* Calendar styles */
    .cal-toolbar { display:flex; gap:8px; align-items:center; padding:8px 0; }
    .cal-toolbar button { padding:4px 8px; }
    .cal-title { flex:1; text-align:center; font-weight:600; color:#e5e7eb; }
    .calendar { display:block; }
  .cal-head { display:grid; grid-template-columns: repeat(7, 1fr); gap:4px; margin-bottom:4px; grid-column: 1 / -1; }
    .cal-head-cell { text-align:center; color:#d1d5db; font-size:12px; }
    .calendar .cal-cell { display:flex; flex-direction:column; border:1px solid #6a6a6a; border-radius:6px; padding:6px; min-height:72px; gap:6px; }
    .calendar { display:grid; grid-template-columns: repeat(7, 1fr); gap:6px; }
    .cal-cell.dim { opacity: 0.5; }
    .cal-cell.today { outline:2px solid #ffffff66; }
    .cal-daynum { font-weight:600; color:#e5e7eb; }
    .cal-badge { align-self:flex-start; background:#FF8200; color:#111; font-weight:600; font-size:12px; padding:2px 6px; border-radius:999px; }
    .calendar-details { margin-top:12px; border-top:1px solid #6a6a6a; padding-top:8px; }
    .cal-details-title { color:#e5e7eb; font-weight:600; margin-bottom:6px; }
    .cal-list { list-style:none; padding:0; margin:0; display:flex; flex-direction:column; gap:6px; }
    .cal-list li { display:flex; align-items:center; gap:8px; background:#585858; border:1px solid #6a6a6a; border-radius:6px; padding:6px 8px; }
    .cal-dot { width:10px; height:10px; border-radius:50%; display:inline-block; }
    .cal-name { color:#f3f4f6; font-weight:600; }
    .cal-when { color:#d1d5db; font-size:12px; margin-left:auto; }

    /* Timeline styles */
    #timeline { overflow:auto; border-top:1px solid #6a6a6a; min-height:320px; }
    .timeline-svg text { user-select:none; }

    /* Tree styles */
    #tree { border-top:1px solid #6a6a6a; }
    .tree-list { display:flex; flex-direction:column; gap:4px; padding:8px 0; }
    .tree-row { display:flex; gap:8px; align-items:center; background:#585858; border:1px solid #6a6a6a; border-radius:6px; padding:6px 8px; }
    .tree-toggle { width:24px; min-width:24px; height:24px; line-height:20px; text-align:center; border:1px solid #cfcfcf; border-radius:6px; background:#fff; color:#222; padding:0; }
    .tree-toggle:disabled { opacity:0.5; }
    .tree-name { color:#f3f4f6; font-weight:600; }
    .tree-when { color:#d1d5db; font-size:12px; margin-left:auto; }
    .tree-progress { color:#111; font-size:12px; font-weight:600; padding:2px 6px; border-radius:999px; margin-left:8px; }

    /* Gantt popup readability (dark theme) */
    .gantt .popup-wrapper { background:#2f2f2f !important; color:#f5f5f5 !important; border:1px solid #6a6a6a; box-shadow: 0 6px 24px rgba(0,0,0,0.35); }
  .gantt .popup-wrapper { font-size:14px !important; line-height:1.4; }
  .gantt .popup-wrapper .title { color:#fff !important; font-size:16px !important; font-weight:700; margin-bottom:6px; }
  .gantt .popup-wrapper .details-container { color:#e5e7eb !important; }
  .gantt .popup-wrapper .details-container div { margin:4px 0; }
    .gantt .popup-wrapper .details-container strong { color:#fff !important; }
    .gantt .popup-wrapper .pointer { border-top-color:#2f2f2f !important; }

    /* Unscoped fallback in case popup is appended to <body> instead of inside .gantt */
    .popup-wrapper { background:#2f2f2f !important; color:#f5f5f5 !important; border:1px solid #6a6a6a; box-shadow: 0 6px 24px rgba(0,0,0,0.35); font-size:14px !important; line-height:1.4; }
    .popup-wrapper .title { color:#fff !important; font-size:16px !important; font-weight:700; margin-bottom:6px; }
    .popup-wrapper .details-container { color:#e5e7eb !important; }
    .popup-wrapper .details-container div { margin:4px 0; }
    .popup-wrapper .details-container strong { color:#fff !important; }
    .popup-wrapper .pointer { border-top-color:#2f2f2f !important; }
  </style>
</body>
</html>
