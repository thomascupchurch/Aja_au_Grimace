<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Project Gantt (Read-only)</title>
  <link rel="icon" href="/favicon.ico">
  <!-- Fallback minimal CSS -->
  <link rel="stylesheet" href="/static/frappe-gantt.css">
  <!-- Optional vendored full CSS (overrides) -->
  <link rel="stylesheet" href="/static/vendor/frappe-gantt.css" onerror="this.remove()">
  <!-- Dark theme overrides to match desktop app (#4B4B4B) -->
  <style>
    :root {
      /* Gantt CSS variable overrides for dark background */
      --g-header-background: #4B4B4B;
      --g-row-color: #585858;
      --g-row-border-color: #6a6a6a;
      --g-text-dark: #f3f4f6;           /* near-white for labels */
      --g-text-muted: #d1d5db;          /* light gray */
      --g-tick-color: #6b7280;          /* slate-ish */
      --g-tick-color-thick: #81858f;
      --g-arrow-color: #d1d5db;
      --g-progress-color: #9ca3af;      /* progress fill on dark */
      --g-expected-progress: #a7a7d6;
      --g-today-highlight: #ffffff66;   /* subtle, semi-transparent */
      --g-actions-background: #4B4B4B;
      --g-popup-actions: #5b5b5b;
      --g-weekend-highlight-color: #4B4B4B; /* blend with background to reduce noise */
      --g-bar-border: transparent;
    }
  </style>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; background:#4B4B4B; color:#f5f5f5; display:flex; flex-direction:column; min-height:100vh; }
    header { padding: 12px 16px; background: #4B4B4B; color: #fff; display:flex; align-items:center; gap:12px; border-bottom:1px solid #6a6a6a; }
    header img { height: 28px; }
  main { padding: 12px; background:#4B4B4B; flex:1; }
    .view { display:block; }
    .view[hidden] { display:none !important; }
    #gantt { overflow-x: auto; border-top: 1px solid #6a6a6a; }
    .toolbar { display:flex; gap:8px; align-items:center; padding:8px 0; }
    .toolbar select, .toolbar button { padding:6px 10px; background:#fff; color:#222; border:1px solid #cfcfcf; border-radius:6px; }
    .toolbar label { color:#e5e7eb; }
    .info { margin: 8px 0; color:#e5e7eb; font-size: 12px; }
    .empty { padding: 24px; color:#e5e7eb; text-align:center; }
    .error { padding: 12px; color: #fee; background:#7f1d1d; border:1px solid #fca5a5; margin:8px 0; border-radius:6px; }
    #gantt > div { min-height: 320px; }
    /* Reduce busyness: hide diagonal hatch for ignored dates */
    .gantt .ignored-bar { display: none; }
    /* Watermark footer */
    .watermark { width: 100%; background: #4B4B4B; border-top: 1px solid #6a6a6a; padding: 6px 12px; display:flex; justify-content:center; }
    .watermark-text { color: #d1d5db; font-size: 12px; opacity: 0.8; user-select: none; }

    /* Mode-specific control visibility */
    body.mode-images .toolbar #view-mode, body.mode-images .toolbar label:nth-of-type(2) { display: none; }

    /* Images gallery */
    .images-toolbar { display:flex; gap:8px; align-items:center; padding:8px 0; }
    .images-toolbar input { padding:6px 10px; border-radius:6px; border:1px solid #cfcfcf; background:#fff; color:#222; }
    .images-grid { --min: 180px; display:grid; grid-template-columns: repeat(auto-fill, minmax(var(--min), 1fr)); gap:10px; border-top:1px solid #6a6a6a; padding-top:10px; }
    .img-card { background:#585858; border:1px solid #6a6a6a; border-radius:8px; overflow:hidden; display:flex; flex-direction:column; cursor:pointer; }
    .img-wrap { position:relative; padding-top:66%; background:#333; }
    .img-wrap img { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
    .img-name { padding:6px 8px; color:#f3f4f6; font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; border-top:1px solid #6a6a6a; background:#4f4f4f; }
    /* Lightbox */
    .lightbox { position:fixed; inset:0; background:rgba(0,0,0,0.85); display:none; align-items:center; justify-content:center; z-index:9999; }
    .lightbox.open { display:flex; }
    .lightbox img { max-width:95vw; max-height:90vh; box-shadow:0 10px 30px rgba(0,0,0,0.6); border-radius:8px; }
    .lightbox .close { position:absolute; top:14px; right:18px; color:#fff; background:#00000066; border:1px solid #ffffff55; border-radius:6px; padding:6px 10px; cursor:pointer; }
    .lightbox .caption { position:absolute; bottom:12px; left:0; right:0; text-align:center; color:#e5e7eb; font-size:12px; }

    /* Hover preview (floating image on hover) */
    .hover-preview { position: fixed; pointer-events: none; z-index: 9998; display:none; }
    .hover-preview.open { display:block; }
    .hover-preview img { max-width: 360px; max-height: 240px; box-shadow: 0 10px 30px rgba(0,0,0,0.55); border-radius: 6px; border: 1px solid #6a6a6a; background:#222; }
    /* Details drawer */
    .details { position: fixed; top: 0; right: 0; bottom: 0; width: min(460px, 92vw); background:#2f2f2f; border-left:1px solid #6a6a6a; box-shadow: -10px 0 30px rgba(0,0,0,0.4); display:flex; flex-direction:column; z-index: 9997; }
    .details[hidden] { display:none !important; }
    .details-header { display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:1px solid #6a6a6a; }
    .details-title { font-weight:700; color:#fff; }
    #details-close { padding:6px 10px; background:#fff; color:#222; border:1px solid #cfcfcf; border-radius:6px; cursor:pointer; }
    .details-body { overflow:auto; padding:10px 12px; color:#e5e7eb; font-size:13px; }
    .kv { display:grid; grid-template-columns: 160px 1fr; gap:6px 10px; }
    .kv .k { color:#d1d5db; }
    .kv .v { color:#f3f4f6; word-break:break-word; }
  </style>
</head>
<body>
  <header>
    <img src="/static/header.png" alt="Header" onerror="this.style.display='none'"/>
    <div>Project Gantt (Read-only)</div>
  </header>
  <main>
    <div class="toolbar">
      <label>Display:</label>
      <select id="display-mode">
        <option value="gantt">Gantt</option>
        <option value="images">Images</option>
      </select>
      <label>View:</label>
      <select id="view-mode">
        <option value="Day">Day</option>
        <option value="Week">Week</option>
        <option value="Month">Month</option>
        <option value="Year">Year</option>
      </select>
      <button id="refresh">Refresh</button>
    </div>
    <div class="info" id="db-info"></div>
    <div class="info" id="status"></div>
    <div id="gantt-view" class="view">
      <div id="gantt"></div>
    </div>
    <div id="images-view" class="view" hidden>
      <div id="images-toolbar" class="images-toolbar">
        <input id="images-filter" type="text" placeholder="Filter images by name..." />
      </div>
      <div id="images" class="images-grid"></div>
    </div>
    <!-- Details Drawer -->
    <aside id="details" class="details" hidden>
      <div class="details-header">
        <div class="details-title">Details</div>
        <button id="details-close" title="Close">âœ•</button>
      </div>
      <div id="details-body" class="details-body"></div>
    </aside>
  </main>
  <footer class="watermark" aria-label="Watermark">
    <div class="watermark-text">{{ watermark }}</div>
  </footer>

  <!-- Prefer local vendored asset (.min.js or .umd.js); fall back to CDN; then to tiny local stub route -->
  <script>
    (function(){
      function inject(src, next){
        var s=document.createElement('script');
        s.src=src;
        s.onload=function(){
          // If script loaded but didn't define Gantt, continue chain
          if(typeof window.Gantt !== 'function') {
            if(next) next();
          }
        };
        s.onerror=function(){ if(next) next(); };
        document.body.appendChild(s);
      }
      // try local vendor (serves .umd.js or .min.js if present & valid)
      inject('/static/vendor/frappe-gantt.umd.js', function(){
        // try CDN UMD
        inject('https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.umd.js', function(){
          // final local stub
          inject('/static/frappe-gantt.umd.js');
        });
      });
    })();
  </script>
  <script>
    let gantt;
    let cachedTasks = null; // cache parsed Date objects for re-render without refetching
    let currentMode = 'gantt';
    let cachedImages = null; // cache image listing

    // Compute overall date range of tasks
    function computeRange(tasks) {
      let min = null, max = null;
      for (const t of tasks || []) {
        if (!(t.start instanceof Date) || !(t.end instanceof Date)) continue;
        if (!min || t.start < min) min = t.start;
        if (!max || t.end > max) max = t.end;
      }
      return { min, max };
    }

    // Count columns for a given view between [start, end] inclusive
    function countColumns(view, start, end) {
      if (!start || !end) return 1;
      const msPerDay = 24*60*60*1000;
      const days = Math.max(1, Math.ceil((end - start) / msPerDay) + 1);
      switch(view) {
        case 'Day':
          return days + 2; // padding
        case 'Week':
          return Math.ceil(days / 7) + 1;
        case 'Month': {
          // Count month ticks inclusive
          let c = 1;
          let d = new Date(start.getFullYear(), start.getMonth()+1, 1);
          while (d <= end) { c++; d = new Date(d.getFullYear(), d.getMonth()+1, 1); }
          return c;
        }
        case 'Year':
          return end.getFullYear() - start.getFullYear() + 1;
        default:
          return days + 2;
      }
    }

    // Choose view mode and column_width that approximately fits container width
    function chooseFitSettings(containerWidth, tasks, preferredView) {
      const { min, max } = computeRange(tasks);
      const views = preferredView ? [preferredView] : ['Day','Week','Month','Year'];
      const bounds = { min: 12, max: 80 };
      for (const v of views) {
        const cols = Math.max(1, countColumns(v, min, max));
        const ideal = Math.floor(containerWidth / cols);
        if (ideal >= bounds.min && ideal <= bounds.max) {
          return { view: v, column_width: ideal };
        }
      }
      // Fallback: pick the last tried view and clamp
      const last = views[views.length - 1];
      const cols = Math.max(1, countColumns(last, min, max));
      return { view: last, column_width: Math.max(bounds.min, Math.min(bounds.max, Math.floor(containerWidth / cols))) };
    }

    function renderGantt(parsed, opts={}) {
      const el = document.querySelector('#gantt');
      el.innerHTML = '';
      const container = document.createElement('div');
      el.appendChild(container);

      const toolbarView = document.querySelector('#view-mode').value;
      const cw = chooseFitSettings(container.clientWidth || el.clientWidth || 1024, parsed, opts.view || toolbarView);
      // keep the select in sync with chosen view
      document.querySelector('#view-mode').value = cw.view;

      // Helper to (re)apply progress colors and add label backgrounds
      const enhanceBars = () => {
        if (!gantt) return;
        gantt.$svg.querySelectorAll('.bar-label-bg').forEach(n => n.remove());
        for (const t of parsed) {
          const group = gantt.$svg.querySelector(`.bar-wrapper[data-id="${t.id}"]`);
          if (!group) continue;
          const prog = group.querySelector('.bar-progress');
          if (prog && t.color_progress) {
            try { prog.style.fill = t.color_progress; } catch {}
          }
          const label = group.querySelector('.bar-label');
          if (label) {
            try {
              const bbox = label.getBBox();
              const padX = 6, padY = 3, rx = 4;
              const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
              rect.setAttribute('x', String(bbox.x - padX));
              rect.setAttribute('y', String(bbox.y - padY));
              rect.setAttribute('width', String(bbox.width + padX * 2));
              rect.setAttribute('height', String(bbox.height + padY * 2));
              rect.setAttribute('rx', String(rx));
              rect.setAttribute('ry', String(rx));
              rect.setAttribute('class', 'bar-label-bg');
              rect.setAttribute('fill', '#FF8200');
              rect.setAttribute('pointer-events', 'none');
              const ie = (t.internal_external || '').toLowerCase();
              const stroke = ie === 'internal' ? '#ffffff' : (ie === 'external' ? '#000000' : 'none');
              const strokeWidth = stroke === 'none' ? '0' : '1.25';
              rect.setAttribute('stroke', stroke);
              rect.setAttribute('stroke-width', strokeWidth);
              label.parentNode.insertBefore(rect, label);
            } catch {}
          }
        }
      };

      gantt = new Gantt(container, parsed, {
        view_mode: cw.view,
        column_width: cw.column_width,
        date_format: 'YYYY-MM-DD',
        language: 'en',
        lines: 'vertical',
        today_button: true,
        ignore: 'weekend',
        holidays: { 'var(--g-weekend-highlight-color)': 'weekend' },
        view_mode_select: true,
        on_view_change: () => { requestAnimationFrame(enhanceBars); },
        custom_popup_html: task => {
          const fields = [
            ['Name', task.name],
            ['Start', t(task.start)],
            ['End', t(task.end)],
            ['Progress', `${task.progress}%`],
            ['Type', task.type],
            ['Dependencies', task.dependencies]
          ];
          function t(d) { try { return d?.toISOString?.().slice(0,10) || d; } catch { return d; } }
          return `<div class="details-container">${fields.map(([k,v]) => `<div><strong>${k}:</strong> ${v||''}</div>`).join('')}</div>`;
        }
      });
      requestAnimationFrame(enhanceBars);
    }

    async function loadTasks() {
      // Show DB path and row count to help diagnose empty data
      try {
        const dbg = await fetch('/api/debug').then(r => r.json());
        const info = document.querySelector('#db-info');
        info.textContent = `DB: ${dbg.db_path || 'unknown'} | exists: ${dbg.db_exists} | project_parts rows: ${dbg.row_count}`;
      } catch (e) {
        console.warn('debug fetch failed', e);
      }

      const res = await fetch('/api/tasks');
      const tasks = await res.json();
      document.querySelector('#status').textContent = `Tasks fetched: ${tasks?.length ?? 0}`;
      const el = document.querySelector('#gantt');
      el.innerHTML = '';
      if (!tasks || tasks.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty';
        empty.textContent = 'No tasks to show. Verify your database path (PROJECT_DB_PATH or db_path.txt) and that project_parts has data.';
        el.appendChild(empty);
        return;
      }
      // Convert to Date objects to avoid client-side parsing quirks
      const parsed = tasks.map(t => ({
        ...t,
        start: new Date(t.start),
        end: new Date(t.end)
      }));
      cachedTasks = parsed;
      try {
        renderGantt(parsed);
      } catch (e) {
        console.error('Gantt render error', e);
        const err = document.createElement('div');
        err.className = 'error';
        err.textContent = `Error rendering Gantt: ${e?.message || e}`;
        el.appendChild(err);
        // As a fallback, list first few tasks
        const pre = document.createElement('pre');
        pre.textContent = JSON.stringify(parsed.slice(0,5), null, 2);
        el.appendChild(pre);
      }
    }

    document.querySelector('#view-mode').addEventListener('change', () => {
      // Re-render with the chosen view, still fitting the width
      if (cachedTasks) renderGantt(cachedTasks, { view: document.querySelector('#view-mode').value });
    });
    document.querySelector('#refresh').addEventListener('click', () => {
      if (currentMode === 'images') { renderImages(true); } else { loadTasks(); }
    });

    // Display mode switching
    function setMode(mode) {
      currentMode = mode;
      document.body.classList.remove('mode-gantt','mode-images');
      document.body.classList.add(`mode-${mode}`);
      document.getElementById('gantt-view').hidden = mode !== 'gantt';
      document.getElementById('images-view').hidden = mode !== 'images';
      if (mode === 'images') { renderImages(); return; }
      if (cachedTasks) renderGantt(cachedTasks); else loadTasks();
    }
    document.getElementById('display-mode').addEventListener('change', (e) => setMode(e.target.value));

    // ---- Images view implementation ----
    async function fetchImages() {
      const res = await fetch('/api/images');
      if (!res.ok) throw new Error('Failed to load images');
      return res.json();
    }

    async function renderImages(forceReload=false) {
      const grid = document.getElementById('images');
      grid.innerHTML = '';
      try {
        if (!cachedImages || forceReload) {
          cachedImages = await fetchImages();
        }
        const filter = (document.getElementById('images-filter').value || '').toLowerCase().trim();
        const items = cachedImages.filter(it => !filter || it.name.toLowerCase().includes(filter));
        if (items.length === 0) {
          const empty = document.createElement('div');
          empty.className = 'empty';
          empty.textContent = 'No images found. Place images under the images/ folder.';
          grid.appendChild(empty);
          return;
        }
        const frag = document.createDocumentFragment();
        for (const it of items) {
          const card = document.createElement('div');
          card.className = 'img-card';
          const wrap = document.createElement('div');
          wrap.className = 'img-wrap';
          const img = document.createElement('img');
          img.loading = 'lazy';
          img.src = it.url;
          img.alt = it.name;
          wrap.appendChild(img);
          const cap = document.createElement('div');
          cap.className = 'img-name';
          cap.textContent = it.name;
          card.appendChild(wrap);
          card.appendChild(cap);
          card.addEventListener('click', () => openLightbox(it.url, it.name));
          frag.appendChild(card);
        }
        grid.appendChild(frag);
      } catch (e) {
        const err = document.createElement('div');
        err.className = 'error';
        err.textContent = `Error loading images: ${e?.message || e}`;
        grid.appendChild(err);
      }
    }

    function openLightbox(url, name) {
      const lb = document.getElementById('lightbox');
      const img = document.getElementById('lightbox-img');
      const cap = document.getElementById('lightbox-cap');
      img.src = url; img.alt = name; cap.textContent = name;
      lb.classList.add('open');
    }
    function closeLightbox() {
      const lb = document.getElementById('lightbox');
      lb.classList.remove('open');
      const img = document.getElementById('lightbox-img');
      img.src = ''; img.alt = '';
    }
    document.addEventListener('DOMContentLoaded', () => {
      const ifi = document.getElementById('images-filter');
      if (ifi) ifi.addEventListener('input', () => renderImages());
      const lbc = document.getElementById('lightbox-close');
      const lb = document.getElementById('lightbox');
      if (lbc) lbc.addEventListener('click', closeLightbox);
      if (lb) lb.addEventListener('click', (e) => { if (e.target === lb) closeLightbox(); });
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeLightbox(); });
    });

    // ---- Hover preview helpers ----
    let hoverRootEl = null;
    let hoverImgEl = null;
    function ensureHoverElements() {
      if (!hoverRootEl) hoverRootEl = document.getElementById('hover-preview');
      if (hoverRootEl && !hoverImgEl) hoverImgEl = hoverRootEl.querySelector('img');
      return !!(hoverRootEl && hoverImgEl);
    }
    function placeHoverAt(evt, pad = 14) {
      if (!ensureHoverElements()) return;
      const vw = window.innerWidth || document.documentElement.clientWidth || 1024;
      const vh = window.innerHeight || document.documentElement.clientHeight || 768;
      const imgMaxW = 360, imgMaxH = 240;
      let x = (evt?.clientX || 0) + pad;
      let y = (evt?.clientY || 0) + pad;
      if (x + imgMaxW + 16 > vw) x = Math.max(8, vw - imgMaxW - 16);
      if (y + imgMaxH + 16 > vh) y = Math.max(8, vh - imgMaxH - 16);
      hoverRootEl.style.left = `${x}px`;
      hoverRootEl.style.top = `${y}px`;
    }
    function showHoverPreview(url, evt) {
      if (!url || !ensureHoverElements()) return;
      hoverImgEl.src = url;
      placeHoverAt(evt);
      hoverRootEl.classList.add('open');
    }
    function moveHoverPreview(evt) {
      if (!ensureHoverElements() || !hoverRootEl.classList.contains('open')) return;
      placeHoverAt(evt);
    }
    function hideHoverPreview() {
      if (!ensureHoverElements()) return;
      hoverRootEl.classList.remove('open');
      hoverImgEl.src = '';
      hoverImgEl.alt = '';
    }
    document.addEventListener('scroll', hideHoverPreview, { passive: true });
    window.addEventListener('blur', hideHoverPreview);

    // Attach hover preview to Images grid
    function bindImageGridHover() {
      const grid = document.getElementById('images');
      if (!grid || grid.dataset.hoverBound === '1') return;
      grid.dataset.hoverBound = '1';
      grid.addEventListener('mousemove', (e) => {
        const card = e.target.closest('.img-card');
        if (!card) { hideHoverPreview(); return; }
        const img = card.querySelector('img');
        if (img && img.src) { showHoverPreview(img.src, e); moveHoverPreview(e); }
      });
      grid.addEventListener('mouseleave', hideHoverPreview);
    }

    // Helper to get first image URL for a task (from cachedTasks entries)
    function firstImageUrlForTask(taskId) {
      if (!cachedTasks) return null;
      const t = cachedTasks.find(tt => tt.id === taskId);
      const img = t && Array.isArray(t.images) && t.images.length ? t.images[0] : null;
      return img ? img.url : null;
    }

    // ---- Details Drawer ----
    function openDetailsForTask(task) {
      if (!task) return;
      const panel = document.getElementById('details');
      const body = document.getElementById('details-body');
      body.innerHTML = '';
      const titleEl = panel.querySelector('.details-title');
      if (titleEl) titleEl.textContent = task.name || 'Details';
      const raw = task.raw && typeof task.raw === 'object' ? task.raw : task;
      const kv = document.createElement('div');
      kv.className = 'kv';
      Object.entries(raw).forEach(([k,v]) => {
        const ke = document.createElement('div'); ke.className='k'; ke.textContent = k;
        const ve = document.createElement('div'); ve.className='v';
        let text = v;
        if (v instanceof Date) text = v.toISOString().slice(0,10);
        else if (v == null) text = '';
        else text = String(v);
        ve.textContent = text;
        kv.appendChild(ke); kv.appendChild(ve);
      });
      if (Array.isArray(task.images) && task.images.length) {
        const hr = document.createElement('hr'); hr.style.borderColor = '#6a6a6a'; hr.style.margin='10px 0';
        const imgs = document.createElement('div'); imgs.style.display='grid'; imgs.style.gridTemplateColumns='repeat(auto-fill, minmax(96px,1fr))'; imgs.style.gap='8px';
        task.images.forEach(im => {
          const a = document.createElement('a'); a.href = im.url; a.target = '_blank'; a.title = im.name;
          const img = document.createElement('img'); img.src = im.url; img.alt = im.name; img.style.width='100%'; img.style.borderRadius='4px'; img.style.border='1px solid #6a6a6a';
          a.appendChild(img); imgs.appendChild(a);
        });
        body.appendChild(kv); body.appendChild(hr); body.appendChild(imgs);
      } else {
        body.appendChild(kv);
      }
      panel.hidden = false;
    }
    function closeDetails() { const panel = document.getElementById('details'); if (panel) panel.hidden = true; }
    document.addEventListener('DOMContentLoaded', () => {
      const x = document.getElementById('details-close');
      if (x) x.addEventListener('click', closeDetails);
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeDetails(); });
    });

    // After Gantt render, bind hover over bars
    function bindGanttHover() {
      try {
        const svg = gantt && gantt.$svg;
        if (!svg || svg.dataset.hoverBound === '1') return;
        svg.dataset.hoverBound = '1';
        svg.addEventListener('mousemove', (e) => {
          const wrap = e.target.closest('.bar-wrapper');
          if (!wrap) { hideHoverPreview(); return; }
          const id = wrap.getAttribute('data-id');
          const url = firstImageUrlForTask(id);
          if (url) { showHoverPreview(url, e); moveHoverPreview(e); } else { hideHoverPreview(); }
        });
        svg.addEventListener('mouseleave', hideHoverPreview);
        svg.addEventListener('click', (e) => {
          const wrap = e.target.closest('.bar-wrapper');
          if (!wrap) return;
          const id = wrap.getAttribute('data-id');
          const t = cachedTasks && cachedTasks.find(tt => tt.id === id);
          if (t) openDetailsForTask(t);
        });
      } catch {}
    }
    const _origRenderGantt = renderGantt;
    renderGantt = function(parsed, opts={}) {
      _origRenderGantt(parsed, opts);
      bindGanttHover();
    }

    loadTasks();

    // Fit on resize
    let resizeTimer = null;
    window.addEventListener('resize', () => {
      if (!cachedTasks) return;
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => renderGantt(cachedTasks), 100);
    });

    // Also bind image grid hover after rendering
    const _origRenderImages = renderImages;
    renderImages = async function(forceReload=false) {
      await _origRenderImages(forceReload);
      setTimeout(() => {
        bindImageGridHover();
        const grid = document.getElementById('images');
        if (grid && !grid.dataset.detailsBound) {
          grid.dataset.detailsBound = '1';
          grid.addEventListener('contextmenu', (e) => {
            const card = e.target.closest('.img-card');
            if (!card) return;
            e.preventDefault();
            const src = card.querySelector('img')?.src || '';
            const file = src.split('/').pop();
            const t = cachedTasks && cachedTasks.find(x => Array.isArray(x.images) && x.images.some(im => im.name === file));
            if (t) openDetailsForTask(t);
          });
        }
      }, 0);
    };

    // Safety: try to bind on load if initial renders have completed
    window.addEventListener('load', () => setTimeout(() => {
      if (currentMode === 'gantt') bindGanttHover();
      if (currentMode === 'images') bindImageGridHover();
    }, 0));
  </script>
  <!-- Hover preview root -->
  <div id="hover-preview" class="hover-preview"><img alt=""/></div>
  <!-- Images lightbox root -->
  <div id="lightbox" class="lightbox" role="dialog" aria-modal="true" aria-label="Image viewer">
    <button class="close" id="lightbox-close" title="Close">Close</button>
    <img id="lightbox-img" alt="" />
    <div class="caption" id="lightbox-cap"></div>
  </div>
</body>
</html>
